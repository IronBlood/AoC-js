import { describe, it, expect } from '@jest/globals';
import {
	parse_grid,
	helper_grid_to_str,
	helper_str_to_grid,
	min_steps,
	min_steps_part2,
} from "./lib.js";

/**
 * @param {import("./types").Location[]} x
 */
const helper_location_stringify = (x) => x.map(l => l.join(",")).sort();

describe("2019-12-20 p1-ut_parse_grid", () => {
	/** @type {[string, import("./types").Grid][]} */
	const testcases = [
		[
			[
				"         A           ",
				"         A           ",
				"  #######.#########  ",
				"  #######.........#  ",
				"  #######.#######.#  ",
				"  #######.#######.#  ",
				"  #######.#######.#  ",
				"  #####  B    ###.#  ",
				"BC...##  C    ###.#  ",
				"  ##.##       ###.#  ",
				"  ##...DE  F  ###.#  ",
				"  #####    G  ###.#  ",
				"  #########.#####.#  ",
				"DE..#######...###.#  ",
				"  #.#########.###.#  ",
				"FG..#########.....#  ",
				"  ###########.#####  ",
				"             Z       ",
				"             Z       ",
			].join("\n"),
			{
				G: helper_str_to_grid([
					"#######.#########",
					"#######.........#",
					"#######.#######.#",
					"#######.#######.#",
					"#######.#######.#",
					"#####       ###.#",
					"...##       ###.#",
					"##.##       ###.#",
					"##...       ###.#",
					"#####       ###.#",
					"#########.#####.#",
					"..#######...###.#",
					"#.#########.###.#",
					"..#########.....#",
					"###########.#####",
				].join("\n")),
				WPs: [
					{ name: "AA", locations: [ [0,7] ] },
					{ name: "BC", locations: [ [4,7], [6,0] ] },
					{ name: "DE", locations: [ [8,4], [11,0] ] },
					{ name: "FG", locations: [ [10,9], [13,0] ] },
					{ name: "ZZ", locations: [ [14,11] ] },
				],
				boundaries: {
					it: 4,
					ib: 10,
					il: 4,
					ir: 12,
				},
			}
		],
	];
	for (let i = 0; i < testcases.length; i++) {
		it(`test-${i}`, () => {
			const tc = testcases[i];
			const grid = parse_grid(tc[0]);

			// check grid
			expect(helper_grid_to_str(grid.G)).toBe(helper_grid_to_str(tc[1].G));

			// check warp points
			/** @type {Map<string, string[]>} */
			const map = new Map();
			for (const wp of grid.WPs) {
				map.set(wp.name, helper_location_stringify(wp.locations));
			}
			expect(map.size).toBe(tc[1].WPs.length);
			for (const wp of tc[1].WPs) {
				expect(map.get(wp.name)).toStrictEqual(helper_location_stringify(wp.locations));
			}

			// check inner boundaries
			expect(grid.boundaries).toStrictEqual(tc[1].boundaries);
		});
	}
});

describe("2019-12-20 p1", () => {
	const testcases = [
		[
			[
				"         A           ",
				"         A           ",
				"  #######.#########  ",
				"  #######.........#  ",
				"  #######.#######.#  ",
				"  #######.#######.#  ",
				"  #######.#######.#  ",
				"  #####  B    ###.#  ",
				"BC...##  C    ###.#  ",
				"  ##.##       ###.#  ",
				"  ##...DE  F  ###.#  ",
				"  #####    G  ###.#  ",
				"  #########.#####.#  ",
				"DE..#######...###.#  ",
				"  #.#########.###.#  ",
				"FG..#########.....#  ",
				"  ###########.#####  ",
				"             Z       ",
				"             Z       ",
			].join("\n"),
			23,
		],
		[
			[
				"                   A               ",
				"                   A               ",
				"  #################.#############  ",
				"  #.#...#...................#.#.#  ",
				"  #.#.#.###.###.###.#########.#.#  ",
				"  #.#.#.......#...#.....#.#.#...#  ",
				"  #.#########.###.#####.#.#.###.#  ",
				"  #.............#.#.....#.......#  ",
				"  ###.###########.###.#####.#.#.#  ",
				"  #.....#        A   C    #.#.#.#  ",
				"  #######        S   P    #####.#  ",
				"  #.#...#                 #......VT",
				"  #.#.#.#                 #.#####  ",
				"  #...#.#               YN....#.#  ",
				"  #.###.#                 #####.#  ",
				"DI....#.#                 #.....#  ",
				"  #####.#                 #.###.#  ",
				"ZZ......#               QG....#..AS",
				"  ###.###                 #######  ",
				"JO..#.#.#                 #.....#  ",
				"  #.#.#.#                 ###.#.#  ",
				"  #...#..DI             BU....#..LF",
				"  #####.#                 #.#####  ",
				"YN......#               VT..#....QG",
				"  #.###.#                 #.###.#  ",
				"  #.#...#                 #.....#  ",
				"  ###.###    J L     J    #.#.###  ",
				"  #.....#    O F     P    #.#...#  ",
				"  #.###.#####.#.#####.#####.###.#  ",
				"  #...#.#.#...#.....#.....#.#...#  ",
				"  #.#####.###.###.#.#.#########.#  ",
				"  #...#.#.....#...#.#.#.#.....#.#  ",
				"  #.###.#####.###.###.#.#.#######  ",
				"  #.#.........#...#.............#  ",
				"  #########.###.###.#############  ",
				"           B   J   C               ",
				"           U   P   P               ",
			].join("\n"),
			58,
		],
	];
	for (let i = 0; i < testcases.length; i++) {
		it(`test-${i}`, () => {
			const tc = testcases[i];
			expect(min_steps(tc[0])).toBe(tc[1]);
		});
	}
});

describe("2019-12-20 p2", () => {
	const testcases = [
		[
			[
				"         A           ",
				"         A           ",
				"  #######.#########  ",
				"  #######.........#  ",
				"  #######.#######.#  ",
				"  #######.#######.#  ",
				"  #######.#######.#  ",
				"  #####  B    ###.#  ",
				"BC...##  C    ###.#  ",
				"  ##.##       ###.#  ",
				"  ##...DE  F  ###.#  ",
				"  #####    G  ###.#  ",
				"  #########.#####.#  ",
				"DE..#######...###.#  ",
				"  #.#########.###.#  ",
				"FG..#########.....#  ",
				"  ###########.#####  ",
				"             Z       ",
				"             Z       ",
			].join("\n"),
			26,
		],
		[
			[
				"             Z L X W       C                 ",
				"             Z P Q B       K                 ",
				"  ###########.#.#.#.#######.###############  ",
				"  #...#.......#.#.......#.#.......#.#.#...#  ",
				"  ###.#.#.#.#.#.#.#.###.#.#.#######.#.#.###  ",
				"  #.#...#.#.#...#.#.#...#...#...#.#.......#  ",
				"  #.###.#######.###.###.#.###.###.#.#######  ",
				"  #...#.......#.#...#...#.............#...#  ",
				"  #.#########.#######.#.#######.#######.###  ",
				"  #...#.#    F       R I       Z    #.#.#.#  ",
				"  #.###.#    D       E C       H    #.#.#.#  ",
				"  #.#...#                           #...#.#  ",
				"  #.###.#                           #.###.#  ",
				"  #.#....OA                       WB..#.#..ZH",
				"  #.###.#                           #.#.#.#  ",
				"CJ......#                           #.....#  ",
				"  #######                           #######  ",
				"  #.#....CK                         #......IC",
				"  #.###.#                           #.###.#  ",
				"  #.....#                           #...#.#  ",
				"  ###.###                           #.#.#.#  ",
				"XF....#.#                         RF..#.#.#  ",
				"  #####.#                           #######  ",
				"  #......CJ                       NM..#...#  ",
				"  ###.#.#                           #.###.#  ",
				"RE....#.#                           #......RF",
				"  ###.###        X   X       L      #.#.#.#  ",
				"  #.....#        F   Q       P      #.#.#.#  ",
				"  ###.###########.###.#######.#########.###  ",
				"  #.....#...#.....#.......#...#.....#.#...#  ",
				"  #####.#.###.#######.#######.###.###.#.#.#  ",
				"  #.......#.......#.#.#.#.#...#...#...#.#.#  ",
				"  #####.###.#####.#.#.#.#.###.###.#.###.###  ",
				"  #.......#.....#.#...#...............#...#  ",
				"  #############.#.#.###.###################  ",
				"               A O F   N                     ",
				"               A A D   M                     ",
			].join("\n"),
			396,
		],
	];
	for (let i = 0; i < testcases.length; i++) {
		it(`test-${i}`, () => {
			const tc = testcases[i];
			expect(min_steps_part2(tc[0])).toBe(tc[1]);
		});
	}
});
